<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>前端模块化</title><meta name="gridsome:hash" content="b37518b001d68aa10baf36bc2360bd3a9bba5ac6"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" data-key="description" name="description" content="Keep Calm And Carry On"><meta data-vue-tag="ssr" name="description"><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.729d5b3bd051080d51f3412be0f7f57d.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.729d5b3bd051080d51f3412be0f7f57d.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="96x96" href="/assets/static/favicon.b9532cc.729d5b3bd051080d51f3412be0f7f57d.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/assets/static/favicon.f22e9f3.729d5b3bd051080d51f3412be0f7f57d.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="152x152" href="/assets/static/favicon.62d22cb.729d5b3bd051080d51f3412be0f7f57d.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="120x120" href="/assets/static/favicon.1539b60.729d5b3bd051080d51f3412be0f7f57d.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="167x167" href="/assets/static/favicon.dc0cdc5.729d5b3bd051080d51f3412be0f7f57d.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="180x180" href="/assets/static/favicon.7b22250.729d5b3bd051080d51f3412be0f7f57d.png"><link rel="preload" href="/assets/css/0.styles.db7a8211.css" as="style"><link rel="preload" href="/assets/js/app.a9596e82.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--post-vue.b96615ae.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules--gridsome--app--pages--404-vue.378b9583.js"><link rel="prefetch" href="/assets/js/page--src--pages--about-vue.b541ca3f.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.f23fcbd2.js"><link rel="prefetch" href="/assets/js/page--src--pages--posts-vue.17585cd4.js"><link rel="prefetch" href="/assets/js/page--src--pages--tags-vue.61ef7270.js"><link rel="prefetch" href="/assets/js/page--src--templates--tag-vue.dac4006a.js"><link rel="stylesheet" href="/assets/css/0.styles.db7a8211.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <script>
      // Add dark / light detection that runs before Vue.js load. Borrowed from overreacted.io
      (function() {
        window.__onThemeChange = function() {};
        function setTheme(newTheme) {
          window.__theme = newTheme;
          preferredTheme = newTheme;
          document.body.setAttribute('data-theme', newTheme);
          window.__onThemeChange(newTheme);
        }

        var preferredTheme;
        try {
          preferredTheme = localStorage.getItem('theme');
        } catch (err) { }

        window.__setPreferredTheme = function(newTheme) {
          setTheme(newTheme);
          try {
            localStorage.setItem('theme', newTheme);
          } catch (err) {}
        }

        var darkQuery = window.matchMedia('(prefers-color-scheme: dark)');
        darkQuery.addListener(function(e) {
          window.__setPreferredTheme(e.matches ? 'dark' : 'light')
        });

        setTheme(preferredTheme || (darkQuery.matches ? 'dark' : 'light'));
      })();
    </script>

    <div id="app" data-server-rendered="true"><header class="header"><div class="header__left"><a href="/" class="logo active"><span class="logo__text">
    Vino
  </span></a></div><div class="header__right"><a href="/posts" class="header__right_text"><span>Posts</span></a><a href="/tags" class="header__right_text"><span>Tags</span></a><button role="button" aria-label="Toggle dark/light" class="toggle-theme"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></button></div></header><main class="main"><div class="post-title"><h1 class="post-title__text">
      前端模块化
    </h1><div class="post-meta">
   发表于 2021/02/18 |  
   
     阅读时长: 2 分钟
   </div></div><div class="post content-box"><div class="post__header"><!----></div><div class="post__content markdown-body"><h1 id="前端模块化概念的产生"><a href="#%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E6%A6%82%E5%BF%B5%E7%9A%84%E4%BA%A7%E7%94%9F" aria-hidden="true"><span class="icon icon-link"></span></a>前端模块化概念的产生</h1>
<p>在JS发展初期就是为了实现简单的页面交互逻辑，但如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等）; 随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀，此时在JS方面就会考虑使用模块化规范去管理。</p>
<h1 id="什么是前端模块化"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96" aria-hidden="true"><span class="icon icon-link"></span></a>什么是前端模块化</h1>
<p>模块: 一个实现特定功能的文件，有了模块可以更方便的使用别人的代码，要用什么功能就加载什么模块。
模块化：</p>
<ul>
<li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li>
<li>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信
与传统前端开发的区别（好处）</li>
<li>避免命名冲突(减少命名空间污染)</li>
<li>更好的分离, 按需加载</li>
<li>更高复用性</li>
<li>高可维护性</li>
</ul>
<h1 id="前端模块化的发展历程"><a href="#%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B" aria-hidden="true"><span class="icon icon-link"></span></a>前端模块化的发展历程</h1>
<blockquote>
<p>模块化发展到今天，已有不少的模块化方案：</p>
</blockquote>
<h2 id="第一阶段：无模块化"><a href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%97%A0%E6%A8%A1%E5%9D%97%E5%8C%96" aria-hidden="true"><span class="icon icon-link"></span></a>第一阶段：无模块化</h2>
<blockquote>
<p>以script标签引入</p>
</blockquote>
<ol>
<li>
<p>全局function模式 : 将不同的功能封装成不同的全局函数</p>
<p>编码: 将不同的功能封装成不同的全局函数</p>
</li>
</ol>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">//...</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">//...</span>
<span class="token punctuation">}</span></code></pre>
<ul>
<li>问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系</li>
</ul>
<ol start="2">
<li>
<p>namespace模式 : 简单对象封装</p>
<p>作用: 减少了全局变量，解决命名冲突</p>
</li>
</ol>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">let</span> myModule <span class="token operator">=</span> <span class="token punctuation">{</span>
  data<span class="token operator">:</span> <span class="token string">'xxx'</span><span class="token punctuation">,</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">foo() </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">data</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
myModule<span class="token punctuation">.</span><span class="token property-access">data</span> <span class="token operator">=</span> <span class="token string">'aaa'</span> <span class="token comment">//能直接修改模块内部的数据</span>
myModule<span class="token punctuation">.</span><span class="token method function property-access">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// foo() aaa</span></code></pre>
<ul>
<li>问题:</li>
</ul>
<ol>
<li>外部可直接修改模块内部的数据，会暴露所有模块成员，导致内部状态可以被外部改写。</li>
<li>数据不安全。</li>
<li>
<p>IIFE模式：立即执行的函数表达式</p>
<ul>
<li>作用: 数据是私有的, 外部只能通过暴露的方法操作</li>
<li>编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口</li>
</ul>
</li>
</ol>
<pre class="language-javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token dom variable">window</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 代码...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token dom variable">window</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>改进：</p>
<ol>
<li>不必为函数命名，避免了污染全局变量；</li>
<li>
<p>IIFE内部形成了单独的作用域，可以封住一些外部无法读取的私有变量
一个页面需要引入多个js文件后出现出现问题：</p>
<ul>
<li>请求过多：首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多</li>
<li>依赖模糊：我们不知道他们的具体依赖关系是什么，容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</li>
<li>后期维护成本较高，难以维护
因此，提出了模块化方案。</li>
</ul>
</li>
</ol>
<h2 id="第二阶段：commonjs（服务器端，同步加载）"><a href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%9Acommonjs%EF%BC%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%EF%BC%8C%E5%90%8C%E6%AD%A5%E5%8A%A0%E8%BD%BD%EF%BC%89" aria-hidden="true"><span class="icon icon-link"></span></a>第二阶段：common.js（服务器端，同步加载）</h2>
<h3 id="提出背景"><a href="#%E6%8F%90%E5%87%BA%E8%83%8C%E6%99%AF" aria-hidden="true"><span class="icon icon-link"></span></a>提出背景</h3>
<p>2009年，node.js项目诞生，将js用于服务器端编程，由于浏览器端网页还比较简单 ，对于模块不是特别依赖，但在服务器端因为要与操作系统和其他应用程序互动，CommonJS就在这样的背景下诞生了。</p>
<h3 id="概述"><a href="#%E6%A6%82%E8%BF%B0" aria-hidden="true"><span class="icon icon-link"></span></a>概述</h3>
<p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</p>
<h3 id="特点"><a href="#%E7%89%B9%E7%82%B9" aria-hidden="true"><span class="icon icon-link"></span></a>特点</h3>
<ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域。</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序。</li>
</ul>
<h3 id="基本语法"><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95" aria-hidden="true"><span class="icon icon-link"></span></a>基本语法</h3>
<ul>
<li>导出模块：<code class="language-text">module.exports = value</code> 或 <code class="language-text">exports.xxx = value</code></li>
<li>引入模块：require(xxx) 注：如果是第三方模块，xxx为模块名； 如果是自定义模块，xxx为模块文件路径</li>
</ul>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">// example.js   这是common.js 规范的模块</span>
<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">addX</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> value <span class="token operator">+</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>  
<span class="token comment">// module代表这个模块； </span>
<span class="token comment">// module.exports属性就是对外暴露的接口；可以对外导出外部可以访问的变量，如这里的x和addX。</span>
module<span class="token punctuation">.</span><span class="token property-access">exports</span><span class="token punctuation">.</span><span class="token property-access">x</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>   
module<span class="token punctuation">.</span><span class="token property-access">exports</span><span class="token punctuation">.</span><span class="token property-access">addX</span> <span class="token operator">=</span> addX<span class="token punctuation">;</span>
<span class="token comment">// 导入example.js模块</span>
<span class="token keyword">var</span> example <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'.example.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span><span class="token property-access">x</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 5</span>
<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span><span class="token method function property-access">addX</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 6</span></code></pre>
<h3 id="模块的加载机制"><a href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6" aria-hidden="true"><span class="icon icon-link"></span></a>模块的加载机制</h3>
<p>输入的是被输出的值的拷贝。即一旦输出一个值，模块内部的变化就影响不到这个值。</p>
<h3 id="优点："><a href="#%E4%BC%98%E7%82%B9%EF%BC%9A" aria-hidden="true"><span class="icon icon-link"></span></a>优点：</h3>
<ol>
<li>CommonJS规范在服务器端率先完成了JavaScript的模块化</li>
<li>解决了依赖、全局变量污染的问题，这也是js运行在服务器端的必要条件。</li>
</ol>
<h3 id="实现"><a href="#%E5%AE%9E%E7%8E%B0" aria-hidden="true"><span class="icon icon-link"></span></a>实现</h3>
<ol>
<li>服务端</li>
<li>浏览器端实现(借助Browserify)</li>
</ol>
<h3 id="为什么浏览器端不使用commonjs规范？"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E4%B8%8D%E4%BD%BF%E7%94%A8commonjs%E8%A7%84%E8%8C%83%EF%BC%9F" aria-hidden="true"><span class="icon icon-link"></span></a>为什么浏览器端不使用commonjs规范？</h3>
<pre class="language-javascript"><code class="language-javascript">举例：
<span class="token keyword">var</span> math <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'math'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
math<span class="token punctuation">.</span><span class="token method function property-access">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>注：第二行math.add(2, 3)，在第一行require('math')之后运行，故必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。
但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于"假死"状态。
因此，浏览器端的模块，不能采用"同步加载"（<code class="language-text">synchronous</code>），只能采用"异步加载"（<code class="language-text">asynchronous</code>）。</p>
<h3 id="缺点："><a href="#%E7%BC%BA%E7%82%B9%EF%BC%9A" aria-hidden="true"><span class="icon icon-link"></span></a>缺点：</h3>
<pre class="language-text"><code class="language-text">由于 CommonJS 是同步加载模块的，在服务器端，文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了，所以，CommonJS是不太适用于浏览器端。</code></pre>
<h2 id="第三阶段：amd（浏览器端，异步加载，模块加载器requirejs）"><a href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%EF%BC%9Aamd%EF%BC%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%EF%BC%8C%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8requirejs%EF%BC%89" aria-hidden="true"><span class="icon icon-link"></span></a>第三阶段：AMD（浏览器端，异步加载，模块加载器require.js）</h2>
<h3 id="提出背景-1"><a href="#%E6%8F%90%E5%87%BA%E8%83%8C%E6%99%AF-1" aria-hidden="true"><span class="icon icon-link"></span></a>提出背景</h3>
<p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。浏览器端的模块，不能采用"同步加载"，只能采用"异步加载"。</p>
<h3 id="基本思想"><a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3" aria-hidden="true"><span class="icon icon-link"></span></a>基本思想</h3>
<p>由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数RequireJS
requireJS主要解决两个问题</p>
<ol>
<li>多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</li>
<li>js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</li>
</ol>
<h3 id="基本语法-1"><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1" aria-hidden="true"><span class="icon icon-link"></span></a>基本语法</h3>
<p>定义暴露模块：</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token comment">//定义没有依赖的模块</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword control-flow">return</span> 模块
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">//定义有依赖的模块</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'module1'</span><span class="token punctuation">,</span> <span class="token string">'module2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">m1<span class="token punctuation">,</span> m2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword control-flow">return</span> 模块
<span class="token punctuation">}</span><span class="token punctuation">)</span>
导入模块：
<span class="token comment">//AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数</span>
<span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'module1'</span><span class="token punctuation">,</span> <span class="token string">'module2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">m1<span class="token punctuation">,</span> m2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   使用m1<span class="token operator">/</span>m2
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<ul>
<li>RequireJS的基本思想：通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载</li>
<li>require( )函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</li>
</ul>
<h3 id="优点"><a href="#%E4%BC%98%E7%82%B9" aria-hidden="true"><span class="icon icon-link"></span></a>优点</h3>
<ol>
<li>适合在浏览器环境中异步加载模块。可以并行加载多个模块</li>
<li>AMD模块定义的方法清晰，不会污染全局环境，能够清楚地显示依赖关系。</li>
</ol>
<h3 id="缺点"><a href="#%E7%BC%BA%E7%82%B9" aria-hidden="true"><span class="icon icon-link"></span></a>缺点</h3>
<ol>
<li>提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅</li>
</ol>
<h2 id="第四阶段：cmd（浏览器端，异步加载，模块加载器seajs）"><a href="#%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%EF%BC%9Acmd%EF%BC%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%EF%BC%8C%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8seajs%EF%BC%89" aria-hidden="true"><span class="icon icon-link"></span></a>第四阶段：CMD（浏览器端，异步加载，模块加载器sea.js）</h2>
<h3 id="提出背景-2"><a href="#%E6%8F%90%E5%87%BA%E8%83%8C%E6%99%AF-2" aria-hidden="true"><span class="icon icon-link"></span></a>提出背景</h3>
<p>在commonjs和amd基础上提出。CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同</p>
<h3 id="基本思想-1"><a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-1" aria-hidden="true"><span class="icon icon-link"></span></a>基本思想</h3>
<p>一个js文件就是一个模块，通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。
CMD推崇就近依赖，只有在用到某个模块的时候再去require 。CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。
在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。</p>
<p><strong>基本语法</strong>
定义模块：</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> module</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 模块代码</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>require：可以把其他模块导入进来的一个参数;</li>
<li>exports：可以把模块内的一些属性和方法导出的;</li>
<li>module：一个对象，上面存储了与当前模块相关联的一些属性和方法。
加载模块：</li>
</ul>
<pre class="language-javascript"><code class="language-javascript">seajs<span class="token punctuation">.</span><span class="token method function property-access">use</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//代码</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token constant">AMD</span>和<span class="token constant">CMD</span>的不同
<span class="token comment">// CMD</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> module</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a'</span><span class="token punctuation">)</span>
  a<span class="token punctuation">.</span><span class="token method function property-access">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 此处略去 100 行</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./b'</span><span class="token punctuation">)</span> <span class="token comment">// 依赖可以就近书写</span>
  b<span class="token punctuation">.</span><span class="token method function property-access">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// ... </span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// AMD </span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'./a'</span><span class="token punctuation">,</span> <span class="token string">'./b'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 依赖必须一开始就写好</span>
  a<span class="token punctuation">.</span><span class="token method function property-access">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 此处略去 100 行</span>
  b<span class="token punctuation">.</span><span class="token method function property-access">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token spread operator">...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
<p><strong>不同点：</strong></p>
<ol>
<li>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块；
CMD推崇就近依赖，只有在用到某个模块的时候再去require</li>
<li>CMD是懒加载, 仅在require时才会加载模块; AMD是预加载, 在定义模块时就提前加载好所有依赖</li>
</ol>
<h3 id="优点-1"><a href="#%E4%BC%98%E7%82%B9-1" aria-hidden="true"><span class="icon icon-link"></span></a>优点</h3>
<ul>
<li>通过按需加载的方式，而不是必须在模块开始就加载所有的依赖</li>
<li>依赖就近，延迟执行</li>
<li>可以很容易在 Node.js 中运行</li>
</ul>
<h3 id="缺点-1"><a href="#%E7%BC%BA%E7%82%B9-1" aria-hidden="true"><span class="icon icon-link"></span></a>缺点</h3>
<ul>
<li>依赖 SPM 打包，模块的加载逻辑偏重</li>
</ul>
<h2 id="第五阶段：es6规范化"><a href="#%E7%AC%AC%E4%BA%94%E9%98%B6%E6%AE%B5%EF%BC%9Aes6%E8%A7%84%E8%8C%83%E5%8C%96" aria-hidden="true"><span class="icon icon-link"></span></a>第五阶段：ES6规范化</h2>
<h3 id="提出背景-3"><a href="#%E6%8F%90%E5%87%BA%E8%83%8C%E6%99%AF-3" aria-hidden="true"><span class="icon icon-link"></span></a>提出背景</h3>
<p>旨在成为浏览器和服务器通用的模块解决方案。ES6的思想希望尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。</p>
<h3 id="基本语法-2"><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2" aria-hidden="true"><span class="icon icon-link"></span></a>基本语法</h3>
<p>其模块功能主要由两个命令构成：export和import。</p>
<ul>
<li>export命令用于规定模块的对外接口;</li>
<li>import命令用于引入其他模块提供的功能。</li>
</ul>
<h3 id="es6-模块与-commonjs-模块的差异"><a href="#es6-%E6%A8%A1%E5%9D%97%E4%B8%8E-commonjs-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82" aria-hidden="true"><span class="icon icon-link"></span></a>ES6 模块与 CommonJS 模块的差异</h3>
<ol>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>
<li>因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li>
</ol>
<h3 id="优点-2"><a href="#%E4%BC%98%E7%82%B9-2" aria-hidden="true"><span class="icon icon-link"></span></a>优点</h3>
<ol>
<li>代码迁移容易</li>
</ol>
<h3 id="局限性："><a href="#%E5%B1%80%E9%99%90%E6%80%A7%EF%BC%9A" aria-hidden="true"><span class="icon icon-link"></span></a>局限性：</h3>
<ol>
<li>ES6目前无法在浏览器中执行，只能通过babel将不被支持的import编译为当前受到广泛支持的 require。</li>
</ol>
</div><div class="post__footer"><div class="post-tags"><a href="/tag/%E6%A8%A1%E5%9D%97%E5%8C%96/" class="post-tags__link"><span>#</span> 模块化
		</a><a href="/tag/CommonJs/" class="post-tags__link"><span>#</span> CommonJs
		</a><a href="/tag/AMD/" class="post-tags__link"><span>#</span> AMD
		</a><a href="/tag/CMD/" class="post-tags__link"><span>#</span> CMD
		</a></div></div></div><div class="post-comments"></div><div class="author post-author"><img alt="Author image" src="data:image/svg+xml,%3csvg fill='none' viewBox='0 0 210 210' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-0306263d1605731f9515d3b9e539fe44'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-0306263d1605731f9515d3b9e539fe44)' width='210' height='210' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCABAAEADASIAAhEBAxEB/8QAGwAAAgMBAQEAAAAAAAAAAAAABQYCAwQHAQD/xAAzEAACAQIFAwQBAQYHAAAAAAABAgMEEQAFEiExBhNBFCJRYXGBByNCkaGxMjM0Q1Lw8f/EABkBAAIDAQAAAAAAAAAAAAAAAAQFAgMGAP/EACwRAAEEAQMBBgYDAAAAAAAAAAEAAgMEEQUhMRITIkFhgZEVJVGhsfBxgsH/2gAMAwEAAhEDEQA/AECqVu3IVH/mBJB4wZlaSxZV1ADcYESkEmwFr4dVeFPWwO0BWrLcrra5kamhLqX0bcg7fyG43w0y9FSRUYlrKyFWOoERm41C%2b2o/JAt%2buNvSmQdQVnSb5jldbS0c01QFjMyspaNAqlrjke23Hg4A13R2fq0qVWeQxpSlSWdtaAX0psN7XuDz/fAktwmQsa4DCDjqARh7m7FZc26crcogiq5NElLIbBlO6/AI5F/nFEd7WO2CeQZb1JGM0fP5BPAaf1EqGVWPsBaNh8gk8DY3IOAiO801hZSfC7DBlWZzwQ7fCDswhuC1aXAticFiRfbFJOJRtZr%2bcXTbsK6hkTtwtkBOkCw4wLrUKyEaebCw5%2bsb4XNrDbH1TT91QT7m/OF9d/S5bLVqxmi7vK6tkEfUGU0WX5dWUndokpFjkaOyvSub7Mp2It5Hm/OE3rqh6gpc9oqXJplqaWe8s7OltCqbnuG%2b6WPj8YGZJ1JVUE03q5zUwRKFK9wiQXvuL3DG43vvbF%2bX9XLmWeiN%2byktTF2YO7/l6%2bV1i4uu2/zhW6GWKVz8BAGWGSNsRznj2SrXJX5XmlHleY1iyQVkDNFUKLBkcH22ud9XO%2b18Ski7c2kDYHY/WO65Z0hSz03Z6rnjq6qXVJ3e2EWFyP8Aa%2bFG2xv8nnHM%2bsOkq/pOWIZpV0c6VDkQS09wZFHJKndSNr%2bN9jhhp9yN5LDyfulmoVHsw9vH4QB9JRNC2v8AeKWJBwSy3L2qNTxSRtGu7HnR%2bRjBUI0UroxBIJ3GGoLXd1KgXRuDhyrCWRbA2tj2KtXu2kXUqLqa49p%2bifvFQ9ynfc4HvUzzZbNEh9qSyKi%2bL8X/ACbDANVjXcrWa1PJEB0HYqytzIVVd6GlcGepOhiiXAuPA4uPHxjKmTw5NVQ1da3eoy3acyU4mCG24Zbg/gj874denoKSienjSgduzEG9SEB97AX%2bybckcYp6zyX19Xl5y/aqqpxCysbIwsfcR8j5xVYkBs9kdhjf2UalBvww3OXZ298flOOXftCoKSgipZ6GfN6bSbvFpKLvYAliN/7DnCD1WaWrrIq2kU0lIikeiV5JBGDyA7Ejfzawxa%2bQV3S9bRzGpgqqCWXtusdwyGxPB5tY4KVVl1PJUVmm2632/lbAhEVSRr65znxRVGuNRgebGBvgeWw35S5ls8kABoXaKM7lCu2//eMTeMMGvcWPk3OKc0jSHL3qqGRkmjsdBjA7nAt8%2bcaVhgmgmnmulSkQMdjsx1DUp%2bdibfYxoHNxusbjqPSFkcmjDeojaJgAbSDSd%2bOcUU8aS0kiow9xJDD%2bhwVzjLKfMc9eHM66WlVk1QItMWLAC1iCeB8k3P8AXC9X0lVltMZqiGP02sxJIjABvi4G4v8AeF1OzEeTuU71Nk0jQMd1uU0fs/zd/TVCVEqo62UsSLGzHyfPGCWb9RQ5NneU1dTD3oRKzFwb39pU7/I1Xwv9K5fQy0%2bXyTUyNM3dQ6xdFbSWTV45sL%2bP0wYzpImihpa/L1M0lH242gYtHDObnUTxp2ReLbt9YomiYbnU7fI39sI%2bG38qdCG4I8f7Z%2bnmrOuep8uzf0FLl0nqVjkSeSZF0XIH%2bED53NzjzMs/M%2bVylxTRRurNqDkBGuSNyd7/ABgR07lDVvUtH3RTUETwxgKgA/fMm582APztgr1rktHR5Oopokq8zkW7AMEKbf8AEbNe/O1tJ%2bcVWIIg9kTQfX%2bVHTnFsDpSfH/P37LmQzCp78bf6jQtgq3IP2f6Yf8Apjp/MMwy41Nc8dPTgM0jyMA7HmwX%2bHxz%2bbHCZkC%2blrpqmoqUUxDQ0es/xfY8C1z%2bmHdepcupaJohrrJt3jp4AWVja5LeABbc7mw4GCb9qcP7OIeqXVqsJYJZHen7uv/Z' /%3e%3c/svg%3e" width="210" data-src="/assets/static/author.25b509d.7283dc95d464f6712f240a76a6ec36e1.jpg" data-srcset="/assets/static/author.25b509d.7283dc95d464f6712f240a76a6ec36e1.jpg 210w" data-sizes="(max-width: 210px) 100vw, 210px" class="author__image g-image g-image--lazy g-image--loading"><noscript><img src="/assets/static/author.25b509d.7283dc95d464f6712f240a76a6ec36e1.jpg" class="author__image g-image g-image--loaded" width="210" alt="Author image"></noscript><!----><div class="contact_me"><i class="font_icon">
			
		</i><i class="font_icon">
			
		</i><i class="font_icon">
			
		</i><i class="font_icon">
			
		</i></div></div></main><footer class="footer"><span class="footer__copyright">© Vino | </span><span class="footer__links">Powered by <a href="//gridsome.org"> Gridsome </a></span></footer></div>
    <script>window.__INITIAL_STATE__={"data":{"post":{"title":"前端模块化","path":"\u002Fpost\u002Fde72bbb2e7dade87b06d1963be3d494e\u002F","date":"2021\u002F02\u002F18","timeToRead":2,"tags":[{"id":"模块化","title":"模块化","path":"\u002Ftag\u002F%E6%A8%A1%E5%9D%97%E5%8C%96\u002F"},{"id":"CommonJs","title":"CommonJs","path":"\u002Ftag\u002FCommonJs\u002F"},{"id":"AMD","title":"AMD","path":"\u002Ftag\u002FAMD\u002F"},{"id":"CMD","title":"CMD","path":"\u002Ftag\u002FCMD\u002F"}],"content":"\u003Ch1 id=\"前端模块化概念的产生\"\u003E\u003Ca href=\"#%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E6%A6%82%E5%BF%B5%E7%9A%84%E4%BA%A7%E7%94%9F\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E前端模块化概念的产生\u003C\u002Fh1\u003E\n\u003Cp\u003E在JS发展初期就是为了实现简单的页面交互逻辑，但如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等）; 随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀，此时在JS方面就会考虑使用模块化规范去管理。\u003C\u002Fp\u003E\n\u003Ch1 id=\"什么是前端模块化\"\u003E\u003Ca href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E什么是前端模块化\u003C\u002Fh1\u003E\n\u003Cp\u003E模块: 一个实现特定功能的文件，有了模块可以更方便的使用别人的代码，要用什么功能就加载什么模块。\n模块化：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起\u003C\u002Fli\u003E\n\u003Cli\u003E块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信\n与传统前端开发的区别（好处）\u003C\u002Fli\u003E\n\u003Cli\u003E避免命名冲突(减少命名空间污染)\u003C\u002Fli\u003E\n\u003Cli\u003E更好的分离, 按需加载\u003C\u002Fli\u003E\n\u003Cli\u003E更高复用性\u003C\u002Fli\u003E\n\u003Cli\u003E高可维护性\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch1 id=\"前端模块化的发展历程\"\u003E\u003Ca href=\"#%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E前端模块化的发展历程\u003C\u002Fh1\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E模块化发展到今天，已有不少的模块化方案：\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch2 id=\"第一阶段：无模块化\"\u003E\u003Ca href=\"#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%97%A0%E6%A8%A1%E5%9D%97%E5%8C%96\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E第一阶段：无模块化\u003C\u002Fh2\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E以script标签引入\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Col\u003E\n\u003Cli\u003E\n\u003Cp\u003E全局function模式 : 将不同的功能封装成不同的全局函数\u003C\u002Fp\u003E\n\u003Cp\u003E编码: 将不同的功能封装成不同的全局函数\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre class=\"language-javascript\"\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"token keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"token function\"\u003Em1\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token comment\"\u003E\u002F\u002F...\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\n\u003Cspan class=\"token keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"token function\"\u003Em2\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token comment\"\u003E\u002F\u002F...\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E\n\u003Cp\u003Enamespace模式 : 简单对象封装\u003C\u002Fp\u003E\n\u003Cp\u003E作用: 减少了全局变量，解决命名冲突\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre class=\"language-javascript\"\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"token keyword\"\u003Elet\u003C\u002Fspan\u003E myModule \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n  data\u003Cspan class=\"token operator\"\u003E:\u003C\u002Fspan\u003E \u003Cspan class=\"token string\"\u003E'xxx'\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token function\"\u003Efoo\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token console class-name\"\u003Econsole\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token method function property-access\"\u003Elog\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token template-string\"\u003E\u003Cspan class=\"token template-punctuation string\"\u003E`\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003Efoo() \u003C\u002Fspan\u003E\u003Cspan class=\"token interpolation\"\u003E\u003Cspan class=\"token interpolation-punctuation punctuation\"\u003E${\u003C\u002Fspan\u003E\u003Cspan class=\"token keyword\"\u003Ethis\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token property-access\"\u003Edata\u003C\u002Fspan\u003E\u003Cspan class=\"token interpolation-punctuation punctuation\"\u003E}\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"token template-punctuation string\"\u003E`\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\nmyModule\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token property-access\"\u003Edata\u003C\u002Fspan\u003E \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"token string\"\u003E'aaa'\u003C\u002Fspan\u003E \u003Cspan class=\"token comment\"\u003E\u002F\u002F能直接修改模块内部的数据\u003C\u002Fspan\u003E\nmyModule\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token method function property-access\"\u003Efoo\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token comment\"\u003E\u002F\u002F foo() aaa\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E问题:\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Col\u003E\n\u003Cli\u003E外部可直接修改模块内部的数据，会暴露所有模块成员，导致内部状态可以被外部改写。\u003C\u002Fli\u003E\n\u003Cli\u003E数据不安全。\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003EIIFE模式：立即执行的函数表达式\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E作用: 数据是私有的, 外部只能通过暴露的方法操作\u003C\u002Fli\u003E\n\u003Cli\u003E编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre class=\"language-javascript\"\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token keyword\"\u003Efunction\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token parameter\"\u003E\u003Cspan class=\"token dom variable\"\u003Ewindow\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token comment\"\u003E\u002F\u002F 代码...\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token dom variable\"\u003Ewindow\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E改进：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E不必为函数命名，避免了污染全局变量；\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003EIIFE内部形成了单独的作用域，可以封住一些外部无法读取的私有变量\n一个页面需要引入多个js文件后出现出现问题：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E请求过多：首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多\u003C\u002Fli\u003E\n\u003Cli\u003E依赖模糊：我们不知道他们的具体依赖关系是什么，容易因为不了解他们之间的依赖关系导致加载先后顺序出错。\u003C\u002Fli\u003E\n\u003Cli\u003E后期维护成本较高，难以维护\n因此，提出了模块化方案。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"第二阶段：commonjs（服务器端，同步加载）\"\u003E\u003Ca href=\"#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%9Acommonjs%EF%BC%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%EF%BC%8C%E5%90%8C%E6%AD%A5%E5%8A%A0%E8%BD%BD%EF%BC%89\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E第二阶段：common.js（服务器端，同步加载）\u003C\u002Fh2\u003E\n\u003Ch3 id=\"提出背景\"\u003E\u003Ca href=\"#%E6%8F%90%E5%87%BA%E8%83%8C%E6%99%AF\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E提出背景\u003C\u002Fh3\u003E\n\u003Cp\u003E2009年，node.js项目诞生，将js用于服务器端编程，由于浏览器端网页还比较简单 ，对于模块不是特别依赖，但在服务器端因为要与操作系统和其他应用程序互动，CommonJS就在这样的背景下诞生了。\u003C\u002Fp\u003E\n\u003Ch3 id=\"概述\"\u003E\u003Ca href=\"#%E6%A6%82%E8%BF%B0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E概述\u003C\u002Fh3\u003E\n\u003Cp\u003ENode 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。\u003C\u002Fp\u003E\n\u003Ch3 id=\"特点\"\u003E\u003Ca href=\"#%E7%89%B9%E7%82%B9\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E特点\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E所有代码都运行在模块作用域，不会污染全局作用域。\u003C\u002Fli\u003E\n\u003Cli\u003E模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。\u003C\u002Fli\u003E\n\u003Cli\u003E模块加载的顺序，按照其在代码中出现的顺序。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"基本语法\"\u003E\u003Ca href=\"#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E基本语法\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E导出模块：\u003Ccode class=\"language-text\"\u003Emodule.exports = value\u003C\u002Fcode\u003E 或 \u003Ccode class=\"language-text\"\u003Eexports.xxx = value\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E引入模块：require(xxx) 注：如果是第三方模块，xxx为模块名； 如果是自定义模块，xxx为模块文件路径\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre class=\"language-javascript\"\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"token comment\"\u003E\u002F\u002F example.js   这是common.js 规范的模块\u003C\u002Fspan\u003E\n\u003Cspan class=\"token keyword\"\u003Evar\u003C\u002Fspan\u003E x \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"token number\"\u003E5\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n\u003Cspan class=\"token keyword\"\u003Evar\u003C\u002Fspan\u003E \u003Cspan class=\"token function-variable function\"\u003EaddX\u003C\u002Fspan\u003E \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"token keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token parameter\"\u003Evalue\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token keyword control-flow\"\u003Ereturn\u003C\u002Fspan\u003E value \u003Cspan class=\"token operator\"\u003E+\u003C\u002Fspan\u003E x\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E  \n\u003Cspan class=\"token comment\"\u003E\u002F\u002F module代表这个模块； \u003C\u002Fspan\u003E\n\u003Cspan class=\"token comment\"\u003E\u002F\u002F module.exports属性就是对外暴露的接口；可以对外导出外部可以访问的变量，如这里的x和addX。\u003C\u002Fspan\u003E\nmodule\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token property-access\"\u003Eexports\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token property-access\"\u003Ex\u003C\u002Fspan\u003E \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E x\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E   \nmodule\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token property-access\"\u003Eexports\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token property-access\"\u003EaddX\u003C\u002Fspan\u003E \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E addX\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n\u003Cspan class=\"token comment\"\u003E\u002F\u002F 导入example.js模块\u003C\u002Fspan\u003E\n\u003Cspan class=\"token keyword\"\u003Evar\u003C\u002Fspan\u003E example \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"token function\"\u003Erequire\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003E'.example.js'\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n\u003Cspan class=\"token console class-name\"\u003Econsole\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token method function property-access\"\u003Elog\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003Eexample\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token property-access\"\u003Ex\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E        \u003Cspan class=\"token comment\"\u003E\u002F\u002F 5\u003C\u002Fspan\u003E\n\u003Cspan class=\"token console class-name\"\u003Econsole\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token method function property-access\"\u003Elog\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003Eexample\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token method function property-access\"\u003EaddX\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token number\"\u003E1\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E  \u003Cspan class=\"token comment\"\u003E\u002F\u002F 6\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"模块的加载机制\"\u003E\u003Ca href=\"#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E模块的加载机制\u003C\u002Fh3\u003E\n\u003Cp\u003E输入的是被输出的值的拷贝。即一旦输出一个值，模块内部的变化就影响不到这个值。\u003C\u002Fp\u003E\n\u003Ch3 id=\"优点：\"\u003E\u003Ca href=\"#%E4%BC%98%E7%82%B9%EF%BC%9A\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E优点：\u003C\u002Fh3\u003E\n\u003Col\u003E\n\u003Cli\u003ECommonJS规范在服务器端率先完成了JavaScript的模块化\u003C\u002Fli\u003E\n\u003Cli\u003E解决了依赖、全局变量污染的问题，这也是js运行在服务器端的必要条件。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"实现\"\u003E\u003Ca href=\"#%E5%AE%9E%E7%8E%B0\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E实现\u003C\u002Fh3\u003E\n\u003Col\u003E\n\u003Cli\u003E服务端\u003C\u002Fli\u003E\n\u003Cli\u003E浏览器端实现(借助Browserify)\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"为什么浏览器端不使用commonjs规范？\"\u003E\u003Ca href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E4%B8%8D%E4%BD%BF%E7%94%A8commonjs%E8%A7%84%E8%8C%83%EF%BC%9F\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E为什么浏览器端不使用commonjs规范？\u003C\u002Fh3\u003E\n\u003Cpre class=\"language-javascript\"\u003E\u003Ccode class=\"language-javascript\"\u003E举例：\n\u003Cspan class=\"token keyword\"\u003Evar\u003C\u002Fspan\u003E math \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"token function\"\u003Erequire\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003E'math'\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\nmath\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token method function property-access\"\u003Eadd\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token number\"\u003E2\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E \u003Cspan class=\"token number\"\u003E3\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E注：第二行math.add(2, 3)，在第一行require('math')之后运行，故必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。\n但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于\"假死\"状态。\n因此，浏览器端的模块，不能采用\"同步加载\"（\u003Ccode class=\"language-text\"\u003Esynchronous\u003C\u002Fcode\u003E），只能采用\"异步加载\"（\u003Ccode class=\"language-text\"\u003Easynchronous\u003C\u002Fcode\u003E）。\u003C\u002Fp\u003E\n\u003Ch3 id=\"缺点：\"\u003E\u003Ca href=\"#%E7%BC%BA%E7%82%B9%EF%BC%9A\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E缺点：\u003C\u002Fh3\u003E\n\u003Cpre class=\"language-text\"\u003E\u003Ccode class=\"language-text\"\u003E由于 CommonJS 是同步加载模块的，在服务器端，文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了，所以，CommonJS是不太适用于浏览器端。\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"第三阶段：amd（浏览器端，异步加载，模块加载器requirejs）\"\u003E\u003Ca href=\"#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%EF%BC%9Aamd%EF%BC%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%EF%BC%8C%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8requirejs%EF%BC%89\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E第三阶段：AMD（浏览器端，异步加载，模块加载器require.js）\u003C\u002Fh2\u003E\n\u003Ch3 id=\"提出背景-1\"\u003E\u003Ca href=\"#%E6%8F%90%E5%87%BA%E8%83%8C%E6%99%AF-1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E提出背景\u003C\u002Fh3\u003E\n\u003Cp\u003ECommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。浏览器端的模块，不能采用\"同步加载\"，只能采用\"异步加载\"。\u003C\u002Fp\u003E\n\u003Ch3 id=\"基本思想\"\u003E\u003Ca href=\"#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E基本思想\u003C\u002Fh3\u003E\n\u003Cp\u003E由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数RequireJS\nrequireJS主要解决两个问题\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\u003C\u002Fli\u003E\n\u003Cli\u003Ejs加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"基本语法-1\"\u003E\u003Ca href=\"#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E基本语法\u003C\u002Fh3\u003E\n\u003Cp\u003E定义暴露模块：\u003C\u002Fp\u003E\n\u003Cpre class=\"language-javascript\"\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"token comment\"\u003E\u002F\u002F定义没有依赖的模块\u003C\u002Fspan\u003E\n\u003Cspan class=\"token function\"\u003Edefine\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token keyword\"\u003Efunction\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n   \u003Cspan class=\"token keyword control-flow\"\u003Ereturn\u003C\u002Fspan\u003E 模块\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n\u003Cspan class=\"token comment\"\u003E\u002F\u002F定义有依赖的模块\u003C\u002Fspan\u003E\n\u003Cspan class=\"token function\"\u003Edefine\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E[\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003E'module1'\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E \u003Cspan class=\"token string\"\u003E'module2'\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E]\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E \u003Cspan class=\"token keyword\"\u003Efunction\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token parameter\"\u003Em1\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E m2\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n   \u003Cspan class=\"token keyword control-flow\"\u003Ereturn\u003C\u002Fspan\u003E 模块\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n导入模块：\n\u003Cspan class=\"token comment\"\u003E\u002F\u002FAMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数\u003C\u002Fspan\u003E\n\u003Cspan class=\"token function\"\u003Erequire\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E[\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003E'module1'\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E \u003Cspan class=\"token string\"\u003E'module2'\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E]\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E \u003Cspan class=\"token keyword\"\u003Efunction\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token parameter\"\u003Em1\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E m2\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n   使用m1\u003Cspan class=\"token operator\"\u003E\u002F\u003C\u002Fspan\u003Em2\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003ERequireJS的基本思想：通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载\u003C\u002Fli\u003E\n\u003Cli\u003Erequire( )函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"优点\"\u003E\u003Ca href=\"#%E4%BC%98%E7%82%B9\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E优点\u003C\u002Fh3\u003E\n\u003Col\u003E\n\u003Cli\u003E适合在浏览器环境中异步加载模块。可以并行加载多个模块\u003C\u002Fli\u003E\n\u003Cli\u003EAMD模块定义的方法清晰，不会污染全局环境，能够清楚地显示依赖关系。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"缺点\"\u003E\u003Ca href=\"#%E7%BC%BA%E7%82%B9\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E缺点\u003C\u002Fh3\u003E\n\u003Col\u003E\n\u003Cli\u003E提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"第四阶段：cmd（浏览器端，异步加载，模块加载器seajs）\"\u003E\u003Ca href=\"#%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%EF%BC%9Acmd%EF%BC%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%EF%BC%8C%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8seajs%EF%BC%89\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E第四阶段：CMD（浏览器端，异步加载，模块加载器sea.js）\u003C\u002Fh2\u003E\n\u003Ch3 id=\"提出背景-2\"\u003E\u003Ca href=\"#%E6%8F%90%E5%87%BA%E8%83%8C%E6%99%AF-2\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E提出背景\u003C\u002Fh3\u003E\n\u003Cp\u003E在commonjs和amd基础上提出。CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同\u003C\u002Fp\u003E\n\u003Ch3 id=\"基本思想-1\"\u003E\u003Ca href=\"#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E基本思想\u003C\u002Fh3\u003E\n\u003Cp\u003E一个js文件就是一个模块，通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。\nCMD推崇就近依赖，只有在用到某个模块的时候再去require 。CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。\n在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E基本语法\u003C\u002Fstrong\u003E\n定义模块：\u003C\u002Fp\u003E\n\u003Cpre class=\"language-javascript\"\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"token function\"\u003Edefine\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token keyword\"\u003Efunction\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token parameter\"\u003Erequire\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E exports\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E module\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token comment\"\u003E\u002F\u002F 模块代码\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003Erequire：可以把其他模块导入进来的一个参数;\u003C\u002Fli\u003E\n\u003Cli\u003Eexports：可以把模块内的一些属性和方法导出的;\u003C\u002Fli\u003E\n\u003Cli\u003Emodule：一个对象，上面存储了与当前模块相关联的一些属性和方法。\n加载模块：\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre class=\"language-javascript\"\u003E\u003Ccode class=\"language-javascript\"\u003Eseajs\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token method function property-access\"\u003Euse\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E[\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E]\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E \u003Cspan class=\"token keyword\"\u003Efunction\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token comment\"\u003E\u002F\u002F代码\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n\u003Cspan class=\"token constant\"\u003EAMD\u003C\u002Fspan\u003E和\u003Cspan class=\"token constant\"\u003ECMD\u003C\u002Fspan\u003E的不同\n\u003Cspan class=\"token comment\"\u003E\u002F\u002F CMD\u003C\u002Fspan\u003E\n\u003Cspan class=\"token function\"\u003Edefine\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token keyword\"\u003Efunction\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token parameter\"\u003Erequire\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E exports\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E module\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token keyword\"\u003Evar\u003C\u002Fspan\u003E a \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"token function\"\u003Erequire\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003E'.\u002Fa'\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n  a\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token method function property-access\"\u003EdoSomething\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token comment\"\u003E\u002F\u002F 此处略去 100 行\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token keyword\"\u003Evar\u003C\u002Fspan\u003E b \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"token function\"\u003Erequire\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003E'.\u002Fb'\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token comment\"\u003E\u002F\u002F 依赖可以就近书写\u003C\u002Fspan\u003E\n  b\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token method function property-access\"\u003EdoSomething\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token comment\"\u003E\u002F\u002F ... \u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n\u003Cspan class=\"token comment\"\u003E\u002F\u002F AMD \u003C\u002Fspan\u003E\n\u003Cspan class=\"token function\"\u003Edefine\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E[\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003E'.\u002Fa'\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E \u003Cspan class=\"token string\"\u003E'.\u002Fb'\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E]\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E \u003Cspan class=\"token keyword\"\u003Efunction\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token parameter\"\u003Ea\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E b\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E \u003Cspan class=\"token comment\"\u003E\u002F\u002F 依赖必须一开始就写好\u003C\u002Fspan\u003E\n  a\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token method function property-access\"\u003EdoSomething\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token comment\"\u003E\u002F\u002F 此处略去 100 行\u003C\u002Fspan\u003E\n  b\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token method function property-access\"\u003EdoSomething\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token spread operator\"\u003E...\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E不同点：\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003EAMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块；\nCMD推崇就近依赖，只有在用到某个模块的时候再去require\u003C\u002Fli\u003E\n\u003Cli\u003ECMD是懒加载, 仅在require时才会加载模块; AMD是预加载, 在定义模块时就提前加载好所有依赖\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"优点-1\"\u003E\u003Ca href=\"#%E4%BC%98%E7%82%B9-1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E优点\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E通过按需加载的方式，而不是必须在模块开始就加载所有的依赖\u003C\u002Fli\u003E\n\u003Cli\u003E依赖就近，延迟执行\u003C\u002Fli\u003E\n\u003Cli\u003E可以很容易在 Node.js 中运行\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"缺点-1\"\u003E\u003Ca href=\"#%E7%BC%BA%E7%82%B9-1\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E缺点\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003E依赖 SPM 打包，模块的加载逻辑偏重\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2 id=\"第五阶段：es6规范化\"\u003E\u003Ca href=\"#%E7%AC%AC%E4%BA%94%E9%98%B6%E6%AE%B5%EF%BC%9Aes6%E8%A7%84%E8%8C%83%E5%8C%96\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E第五阶段：ES6规范化\u003C\u002Fh2\u003E\n\u003Ch3 id=\"提出背景-3\"\u003E\u003Ca href=\"#%E6%8F%90%E5%87%BA%E8%83%8C%E6%99%AF-3\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E提出背景\u003C\u002Fh3\u003E\n\u003Cp\u003E旨在成为浏览器和服务器通用的模块解决方案。ES6的思想希望尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。\u003C\u002Fp\u003E\n\u003Ch3 id=\"基本语法-2\"\u003E\u003Ca href=\"#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E基本语法\u003C\u002Fh3\u003E\n\u003Cp\u003E其模块功能主要由两个命令构成：export和import。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Eexport命令用于规定模块的对外接口;\u003C\u002Fli\u003E\n\u003Cli\u003Eimport命令用于引入其他模块提供的功能。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"es6-模块与-commonjs-模块的差异\"\u003E\u003Ca href=\"#es6-%E6%A8%A1%E5%9D%97%E4%B8%8E-commonjs-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EES6 模块与 CommonJS 模块的差异\u003C\u002Fh3\u003E\n\u003Col\u003E\n\u003Cli\u003ECommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\u003C\u002Fli\u003E\n\u003Cli\u003ECommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\u003C\u002Fli\u003E\n\u003Cli\u003E因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"优点-2\"\u003E\u003Ca href=\"#%E4%BC%98%E7%82%B9-2\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E优点\u003C\u002Fh3\u003E\n\u003Col\u003E\n\u003Cli\u003E代码迁移容易\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"局限性：\"\u003E\u003Ca href=\"#%E5%B1%80%E9%99%90%E6%80%A7%EF%BC%9A\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E局限性：\u003C\u002Fh3\u003E\n\u003Col\u003E\n\u003Cli\u003EES6目前无法在浏览器中执行，只能通过babel将不被支持的import编译为当前受到广泛支持的 require。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n"}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.a9596e82.js" defer></script><script src="/assets/js/page--src--templates--post-vue.b96615ae.js" defer></script>
  </body>
</html>