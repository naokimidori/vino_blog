---
title: 前端模块化
date: 2021-02-18
tags: ['模块化', 'CommonJs', 'AMD', 'CMD']
---

# 前端模块化概念的产生

在JS发展初期就是为了实现简单的页面交互逻辑，但如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等）; 随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀，此时在JS方面就会考虑使用模块化规范去管理。

# 什么是前端模块化

模块: 一个实现特定功能的文件，有了模块可以更方便的使用别人的代码，要用什么功能就加载什么模块。
模块化：
- 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起
- 块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信
与传统前端开发的区别（好处）
- 避免命名冲突(减少命名空间污染)
- 更好的分离, 按需加载
- 更高复用性
- 高可维护性

# 前端模块化的发展历程

> 模块化发展到今天，已有不少的模块化方案：

## 第一阶段：无模块化

> 以script标签引入

1. 全局function模式 : 将不同的功能封装成不同的全局函数

   编码: 将不同的功能封装成不同的全局函数

```javascript
function m1(){
  //...
}
function m2(){
  //...
}
```

- 问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系

2. namespace模式 : 简单对象封装
   
   作用: 减少了全局变量，解决命名冲突

```javascript
let myModule = {
  data: 'xxx',
  foo() {
    console.log(`foo() ${this.data}`)
  },
}
myModule.data = 'aaa' //能直接修改模块内部的数据
myModule.foo() // foo() aaa
```

- 问题:

1. 外部可直接修改模块内部的数据，会暴露所有模块成员，导致内部状态可以被外部改写。
1. 数据不安全。
1. IIFE模式：立即执行的函数表达式
   - 作用: 数据是私有的, 外部只能通过暴露的方法操作
   - 编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口

```javascript
(function(window) {
    // 代码...
})(window);
```

改进：

1. 不必为函数命名，避免了污染全局变量；
1. IIFE内部形成了单独的作用域，可以封住一些外部无法读取的私有变量
   一个页面需要引入多个js文件后出现出现问题：
   - 请求过多：首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多
   - 依赖模糊：我们不知道他们的具体依赖关系是什么，容易因为不了解他们之间的依赖关系导致加载先后顺序出错。
   - 后期维护成本较高，难以维护
   因此，提出了模块化方案。



## 第二阶段：common.js（服务器端，同步加载）

### 提出背景

2009年，node.js项目诞生，将js用于服务器端编程，由于浏览器端网页还比较简单 ，对于模块不是特别依赖，但在服务器端因为要与操作系统和其他应用程序互动，CommonJS就在这样的背景下诞生了。

### 概述

Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。

### 特点

- 所有代码都运行在模块作用域，不会污染全局作用域。
- 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
- 模块加载的顺序，按照其在代码中出现的顺序。

### 基本语法

- 导出模块：`module.exports = value` 或 `exports.xxx = value`
- 引入模块：require(xxx) 注：如果是第三方模块，xxx为模块名； 如果是自定义模块，xxx为模块文件路径

```javascript
// example.js   这是common.js 规范的模块
var x = 5;
var addX = function (value) {
  return value + x;
};  
// module代表这个模块； 
// module.exports属性就是对外暴露的接口；可以对外导出外部可以访问的变量，如这里的x和addX。
module.exports.x = x;   
module.exports.addX = addX;
// 导入example.js模块
var example = require('.example.js');
console.log(example.x);        // 5
console.log(example.addX(1));  // 6
```

### 模块的加载机制

输入的是被输出的值的拷贝。即一旦输出一个值，模块内部的变化就影响不到这个值。

### 优点：

1. CommonJS规范在服务器端率先完成了JavaScript的模块化
1. 解决了依赖、全局变量污染的问题，这也是js运行在服务器端的必要条件。

### 实现

1. 服务端
1. 浏览器端实现(借助Browserify)

### 为什么浏览器端不使用commonjs规范？

```javascript
举例：
var math = require('math');
math.add(2, 3);
```

注：第二行math.add(2, 3)，在第一行require('math')之后运行，故必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。
但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于"假死"状态。
因此，浏览器端的模块，不能采用"同步加载"（`synchronous`），只能采用"异步加载"（`asynchronous`）。

### 缺点：

```
由于 CommonJS 是同步加载模块的，在服务器端，文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了，所以，CommonJS是不太适用于浏览器端。
```

## 第三阶段：AMD（浏览器端，异步加载，模块加载器require.js）

### 提出背景

CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。浏览器端的模块，不能采用"同步加载"，只能采用"异步加载"。

### 基本思想

由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数RequireJS
requireJS主要解决两个问题

1. 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器
1. js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长

### 基本语法

定义暴露模块：

```javascript
//定义没有依赖的模块
define(function(){
   return 模块
})
//定义有依赖的模块
define(['module1', 'module2'], function(m1, m2){
   return 模块
})
导入模块：
//AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数
require(['module1', 'module2'], function(m1, m2){
   使用m1/m2
})
```

- RequireJS的基本思想：通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载
- require( )函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。

### 优点

1. 适合在浏览器环境中异步加载模块。可以并行加载多个模块
1. AMD模块定义的方法清晰，不会污染全局环境，能够清楚地显示依赖关系。

### 缺点

1. 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅

## 第四阶段：CMD（浏览器端，异步加载，模块加载器sea.js）

### 提出背景

在commonjs和amd基础上提出。CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同

### 基本思想

一个js文件就是一个模块，通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。
CMD推崇就近依赖，只有在用到某个模块的时候再去require 。CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。
在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。


**基本语法**
定义模块：

```javascript
define(function(require, exports, module) {
  // 模块代码
});
```

- require：可以把其他模块导入进来的一个参数;
- exports：可以把模块内的一些属性和方法导出的;
- module：一个对象，上面存储了与当前模块相关联的一些属性和方法。
加载模块：

```javascript
seajs.use([], function(){
    //代码
});
AMD和CMD的不同
// CMD
define(function(require, exports, module) {
  var a = require('./a')
  a.doSomething()
  // 此处略去 100 行
  var b = require('./b') // 依赖可以就近书写
  b.doSomething()
  // ... 
})
// AMD 
define(['./a', './b'], function(a, b) { // 依赖必须一开始就写好
  a.doSomething()
  // 此处略去 100 行
  b.doSomething()
  ...
})
```

**不同点：**

1. AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块；
   CMD推崇就近依赖，只有在用到某个模块的时候再去require
1. CMD是懒加载, 仅在require时才会加载模块; AMD是预加载, 在定义模块时就提前加载好所有依赖

### 优点

- 通过按需加载的方式，而不是必须在模块开始就加载所有的依赖
- 依赖就近，延迟执行
- 可以很容易在 Node.js 中运行

### 缺点

- 依赖 SPM 打包，模块的加载逻辑偏重

## 第五阶段：ES6规范化

### 提出背景

旨在成为浏览器和服务器通用的模块解决方案。ES6的思想希望尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。

### 基本语法

其模块功能主要由两个命令构成：export和import。
- export命令用于规定模块的对外接口;
- import命令用于引入其他模块提供的功能。

### ES6 模块与 CommonJS 模块的差异

1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
1. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
1. 因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

### 优点

1. 代码迁移容易

### 局限性：

1. ES6目前无法在浏览器中执行，只能通过babel将不被支持的import编译为当前受到广泛支持的 require。