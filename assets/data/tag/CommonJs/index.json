{"hash":"b37518b001d68aa10baf36bc2360bd3a9bba5ac6","data":{"tag":{"title":"CommonJs","belongsTo":{"edges":[{"node":{"title":"前端模块化","path":"/post/de72bbb2e7dade87b06d1963be3d494e/","date":"2021/02/18","timeToRead":2,"content":"<h1 id=\"前端模块化概念的产生\"><a href=\"#%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E6%A6%82%E5%BF%B5%E7%9A%84%E4%BA%A7%E7%94%9F\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>前端模块化概念的产生</h1>\n<p>在JS发展初期就是为了实现简单的页面交互逻辑，但如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等）; 随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀，此时在JS方面就会考虑使用模块化规范去管理。</p>\n<h1 id=\"什么是前端模块化\"><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>什么是前端模块化</h1>\n<p>模块: 一个实现特定功能的文件，有了模块可以更方便的使用别人的代码，要用什么功能就加载什么模块。\n模块化：</p>\n<ul>\n<li>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</li>\n<li>块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信\n与传统前端开发的区别（好处）</li>\n<li>避免命名冲突(减少命名空间污染)</li>\n<li>更好的分离, 按需加载</li>\n<li>更高复用性</li>\n<li>高可维护性</li>\n</ul>\n<h1 id=\"前端模块化的发展历程\"><a href=\"#%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>前端模块化的发展历程</h1>\n<blockquote>\n<p>模块化发展到今天，已有不少的模块化方案：</p>\n</blockquote>\n<h2 id=\"第一阶段：无模块化\"><a href=\"#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%97%A0%E6%A8%A1%E5%9D%97%E5%8C%96\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>第一阶段：无模块化</h2>\n<blockquote>\n<p>以script标签引入</p>\n</blockquote>\n<ol>\n<li>\n<p>全局function模式 : 将不同的功能封装成不同的全局函数</p>\n<p>编码: 将不同的功能封装成不同的全局函数</p>\n</li>\n</ol>\n<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">m1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//...</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">m2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//...</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li>问题: 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系</li>\n</ul>\n<ol start=\"2\">\n<li>\n<p>namespace模式 : 简单对象封装</p>\n<p>作用: 减少了全局变量，解决命名冲突</p>\n</li>\n</ol>\n<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> myModule <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  data<span class=\"token operator\">:</span> <span class=\"token string\">'xxx'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token console class-name\">console</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">foo() </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">data</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\nmyModule<span class=\"token punctuation\">.</span><span class=\"token property-access\">data</span> <span class=\"token operator\">=</span> <span class=\"token string\">'aaa'</span> <span class=\"token comment\">//能直接修改模块内部的数据</span>\nmyModule<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// foo() aaa</span></code></pre>\n<ul>\n<li>问题:</li>\n</ul>\n<ol>\n<li>外部可直接修改模块内部的数据，会暴露所有模块成员，导致内部状态可以被外部改写。</li>\n<li>数据不安全。</li>\n<li>\n<p>IIFE模式：立即执行的函数表达式</p>\n<ul>\n<li>作用: 数据是私有的, 外部只能通过暴露的方法操作</li>\n<li>编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口</li>\n</ul>\n</li>\n</ol>\n<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token dom variable\">window</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 代码...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token dom variable\">window</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>改进：</p>\n<ol>\n<li>不必为函数命名，避免了污染全局变量；</li>\n<li>\n<p>IIFE内部形成了单独的作用域，可以封住一些外部无法读取的私有变量\n一个页面需要引入多个js文件后出现出现问题：</p>\n<ul>\n<li>请求过多：首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多</li>\n<li>依赖模糊：我们不知道他们的具体依赖关系是什么，容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</li>\n<li>后期维护成本较高，难以维护\n因此，提出了模块化方案。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"第二阶段：commonjs（服务器端，同步加载）\"><a href=\"#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%9Acommonjs%EF%BC%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%EF%BC%8C%E5%90%8C%E6%AD%A5%E5%8A%A0%E8%BD%BD%EF%BC%89\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>第二阶段：common.js（服务器端，同步加载）</h2>\n<h3 id=\"提出背景\"><a href=\"#%E6%8F%90%E5%87%BA%E8%83%8C%E6%99%AF\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>提出背景</h3>\n<p>2009年，node.js项目诞生，将js用于服务器端编程，由于浏览器端网页还比较简单 ，对于模块不是特别依赖，但在服务器端因为要与操作系统和其他应用程序互动，CommonJS就在这样的背景下诞生了。</p>\n<h3 id=\"概述\"><a href=\"#%E6%A6%82%E8%BF%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>概述</h3>\n<p>Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</p>\n<h3 id=\"特点\"><a href=\"#%E7%89%B9%E7%82%B9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>特点</h3>\n<ul>\n<li>所有代码都运行在模块作用域，不会污染全局作用域。</li>\n<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>\n<li>模块加载的顺序，按照其在代码中出现的顺序。</li>\n</ul>\n<h3 id=\"基本语法\"><a href=\"#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>基本语法</h3>\n<ul>\n<li>导出模块：<code class=\"language-text\">module.exports = value</code> 或 <code class=\"language-text\">exports.xxx = value</code></li>\n<li>引入模块：require(xxx) 注：如果是第三方模块，xxx为模块名； 如果是自定义模块，xxx为模块文件路径</li>\n</ul>\n<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// example.js   这是common.js 规范的模块</span>\n<span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">addX</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">value</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword control-flow\">return</span> value <span class=\"token operator\">+</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>  \n<span class=\"token comment\">// module代表这个模块； </span>\n<span class=\"token comment\">// module.exports属性就是对外暴露的接口；可以对外导出外部可以访问的变量，如这里的x和addX。</span>\nmodule<span class=\"token punctuation\">.</span><span class=\"token property-access\">exports</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">x</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>   \nmodule<span class=\"token punctuation\">.</span><span class=\"token property-access\">exports</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">addX</span> <span class=\"token operator\">=</span> addX<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 导入example.js模块</span>\n<span class=\"token keyword\">var</span> example <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.example.js'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token console class-name\">console</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">log</span><span class=\"token punctuation\">(</span>example<span class=\"token punctuation\">.</span><span class=\"token property-access\">x</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 5</span>\n<span class=\"token console class-name\">console</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">log</span><span class=\"token punctuation\">(</span>example<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">addX</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 6</span></code></pre>\n<h3 id=\"模块的加载机制\"><a href=\"#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>模块的加载机制</h3>\n<p>输入的是被输出的值的拷贝。即一旦输出一个值，模块内部的变化就影响不到这个值。</p>\n<h3 id=\"优点：\"><a href=\"#%E4%BC%98%E7%82%B9%EF%BC%9A\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>优点：</h3>\n<ol>\n<li>CommonJS规范在服务器端率先完成了JavaScript的模块化</li>\n<li>解决了依赖、全局变量污染的问题，这也是js运行在服务器端的必要条件。</li>\n</ol>\n<h3 id=\"实现\"><a href=\"#%E5%AE%9E%E7%8E%B0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>实现</h3>\n<ol>\n<li>服务端</li>\n<li>浏览器端实现(借助Browserify)</li>\n</ol>\n<h3 id=\"为什么浏览器端不使用commonjs规范？\"><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E4%B8%8D%E4%BD%BF%E7%94%A8commonjs%E8%A7%84%E8%8C%83%EF%BC%9F\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>为什么浏览器端不使用commonjs规范？</h3>\n<pre class=\"language-javascript\"><code class=\"language-javascript\">举例：\n<span class=\"token keyword\">var</span> math <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'math'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmath<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>注：第二行math.add(2, 3)，在第一行require('math')之后运行，故必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。\n但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于\"假死\"状态。\n因此，浏览器端的模块，不能采用\"同步加载\"（<code class=\"language-text\">synchronous</code>），只能采用\"异步加载\"（<code class=\"language-text\">asynchronous</code>）。</p>\n<h3 id=\"缺点：\"><a href=\"#%E7%BC%BA%E7%82%B9%EF%BC%9A\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>缺点：</h3>\n<pre class=\"language-text\"><code class=\"language-text\">由于 CommonJS 是同步加载模块的，在服务器端，文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了，所以，CommonJS是不太适用于浏览器端。</code></pre>\n<h2 id=\"第三阶段：amd（浏览器端，异步加载，模块加载器requirejs）\"><a href=\"#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%EF%BC%9Aamd%EF%BC%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%EF%BC%8C%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8requirejs%EF%BC%89\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>第三阶段：AMD（浏览器端，异步加载，模块加载器require.js）</h2>\n<h3 id=\"提出背景-1\"><a href=\"#%E6%8F%90%E5%87%BA%E8%83%8C%E6%99%AF-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>提出背景</h3>\n<p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。浏览器端的模块，不能采用\"同步加载\"，只能采用\"异步加载\"。</p>\n<h3 id=\"基本思想\"><a href=\"#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>基本思想</h3>\n<p>由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数RequireJS\nrequireJS主要解决两个问题</p>\n<ol>\n<li>多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</li>\n<li>js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</li>\n</ol>\n<h3 id=\"基本语法-1\"><a href=\"#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>基本语法</h3>\n<p>定义暴露模块：</p>\n<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//定义没有依赖的模块</span>\n<span class=\"token function\">define</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n   <span class=\"token keyword control-flow\">return</span> 模块\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//定义有依赖的模块</span>\n<span class=\"token function\">define</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'module1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'module2'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">m1<span class=\"token punctuation\">,</span> m2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n   <span class=\"token keyword control-flow\">return</span> 模块\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n导入模块：\n<span class=\"token comment\">//AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数</span>\n<span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'module1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'module2'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">m1<span class=\"token punctuation\">,</span> m2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n   使用m1<span class=\"token operator\">/</span>m2\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre>\n<ul>\n<li>RequireJS的基本思想：通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载</li>\n<li>require( )函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</li>\n</ul>\n<h3 id=\"优点\"><a href=\"#%E4%BC%98%E7%82%B9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>优点</h3>\n<ol>\n<li>适合在浏览器环境中异步加载模块。可以并行加载多个模块</li>\n<li>AMD模块定义的方法清晰，不会污染全局环境，能够清楚地显示依赖关系。</li>\n</ol>\n<h3 id=\"缺点\"><a href=\"#%E7%BC%BA%E7%82%B9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>缺点</h3>\n<ol>\n<li>提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅</li>\n</ol>\n<h2 id=\"第四阶段：cmd（浏览器端，异步加载，模块加载器seajs）\"><a href=\"#%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%EF%BC%9Acmd%EF%BC%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%EF%BC%8C%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%EF%BC%8C%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8seajs%EF%BC%89\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>第四阶段：CMD（浏览器端，异步加载，模块加载器sea.js）</h2>\n<h3 id=\"提出背景-2\"><a href=\"#%E6%8F%90%E5%87%BA%E8%83%8C%E6%99%AF-2\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>提出背景</h3>\n<p>在commonjs和amd基础上提出。CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同</p>\n<h3 id=\"基本思想-1\"><a href=\"#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>基本思想</h3>\n<p>一个js文件就是一个模块，通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。\nCMD推崇就近依赖，只有在用到某个模块的时候再去require 。CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。\n在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。</p>\n<p><strong>基本语法</strong>\n定义模块：</p>\n<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">define</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">require<span class=\"token punctuation\">,</span> exports<span class=\"token punctuation\">,</span> module</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 模块代码</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<ul>\n<li>require：可以把其他模块导入进来的一个参数;</li>\n<li>exports：可以把模块内的一些属性和方法导出的;</li>\n<li>module：一个对象，上面存储了与当前模块相关联的一些属性和方法。\n加载模块：</li>\n</ul>\n<pre class=\"language-javascript\"><code class=\"language-javascript\">seajs<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">use</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//代码</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token constant\">AMD</span>和<span class=\"token constant\">CMD</span>的不同\n<span class=\"token comment\">// CMD</span>\n<span class=\"token function\">define</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">require<span class=\"token punctuation\">,</span> exports<span class=\"token punctuation\">,</span> module</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./a'</span><span class=\"token punctuation\">)</span>\n  a<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// 此处略去 100 行</span>\n  <span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./b'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 依赖可以就近书写</span>\n  b<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// ... </span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// AMD </span>\n<span class=\"token function\">define</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'./a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'./b'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 依赖必须一开始就写好</span>\n  a<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// 此处略去 100 行</span>\n  b<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token spread operator\">...</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre>\n<p><strong>不同点：</strong></p>\n<ol>\n<li>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块；\nCMD推崇就近依赖，只有在用到某个模块的时候再去require</li>\n<li>CMD是懒加载, 仅在require时才会加载模块; AMD是预加载, 在定义模块时就提前加载好所有依赖</li>\n</ol>\n<h3 id=\"优点-1\"><a href=\"#%E4%BC%98%E7%82%B9-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>优点</h3>\n<ul>\n<li>通过按需加载的方式，而不是必须在模块开始就加载所有的依赖</li>\n<li>依赖就近，延迟执行</li>\n<li>可以很容易在 Node.js 中运行</li>\n</ul>\n<h3 id=\"缺点-1\"><a href=\"#%E7%BC%BA%E7%82%B9-1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>缺点</h3>\n<ul>\n<li>依赖 SPM 打包，模块的加载逻辑偏重</li>\n</ul>\n<h2 id=\"第五阶段：es6规范化\"><a href=\"#%E7%AC%AC%E4%BA%94%E9%98%B6%E6%AE%B5%EF%BC%9Aes6%E8%A7%84%E8%8C%83%E5%8C%96\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>第五阶段：ES6规范化</h2>\n<h3 id=\"提出背景-3\"><a href=\"#%E6%8F%90%E5%87%BA%E8%83%8C%E6%99%AF-3\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>提出背景</h3>\n<p>旨在成为浏览器和服务器通用的模块解决方案。ES6的思想希望尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。</p>\n<h3 id=\"基本语法-2\"><a href=\"#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>基本语法</h3>\n<p>其模块功能主要由两个命令构成：export和import。</p>\n<ul>\n<li>export命令用于规定模块的对外接口;</li>\n<li>import命令用于引入其他模块提供的功能。</li>\n</ul>\n<h3 id=\"es6-模块与-commonjs-模块的差异\"><a href=\"#es6-%E6%A8%A1%E5%9D%97%E4%B8%8E-commonjs-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ES6 模块与 CommonJS 模块的差异</h3>\n<ol>\n<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>\n<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li>\n<li>因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li>\n</ol>\n<h3 id=\"优点-2\"><a href=\"#%E4%BC%98%E7%82%B9-2\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>优点</h3>\n<ol>\n<li>代码迁移容易</li>\n</ol>\n<h3 id=\"局限性：\"><a href=\"#%E5%B1%80%E9%99%90%E6%80%A7%EF%BC%9A\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>局限性：</h3>\n<ol>\n<li>ES6目前无法在浏览器中执行，只能通过babel将不被支持的import编译为当前受到广泛支持的 require。</li>\n</ol>\n"}}]}}},"context":{}}